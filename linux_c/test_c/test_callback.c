#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<unistd.h>
#include<errno.h>

#include<pthread.h>
#include<semaphore.h>

#define OVER (-1)
#define NUM_THREADS 5//线程数
#define BUFFER_SIZE 16//缓冲区数量

/*
void* 指针,NULL指针,零指针,野指针,悬垂指针;

void* 类型指针:通用变体类型指针,可以不经转换,赋给其他指针,函数指针除外;malloc返回的就是void*类型;
NULL指针:是一个标准规定的宏定义;#define NULL((void*) 0) 用来表示空指针常量;
零指针:指针值为0,零值指针,没有存储任何内存地址的指针;可以使任意一种指针类型;eg:void* ;int *;double*;
空指针:指针赋值为0;0*7,3-3等之后,指针即变成空指针;即:空指针不指向任何实际的对象或者函数;NULL指针和零指针都是空指针;
野指针:指向垃圾内存的指针;1.>指针变量没有初始化;2.>指针被delete或者free之后没有置为空;3.>指针操作超越了变量的范围;
<注:使用没有初始化的指针(野指针)的结果是未定义的>;

"野指针"的成因主要有两种:
1.>指针变量没有被初始化;任何指针变量刚被创建时,不会自动成为NULL指针,它的缺省值是随机的,它会乱指一气;
所以,指针变量在创建的同时应当被初始化,要么将指针设置为NULL,要么让它指向合法的内存;
char* p=NULL:
char* str=(char*)malloc(100);
2.>指针p被free或者delete之后,没有设置为NULL,让人误以为p是个合法的指针;
free和delete只是把指针的内存给释放掉,但并没有把指针本身释放掉;free以后
其地址仍然不变(非NULL),只是该地址对应的内存是垃圾,p就变成了"野指针";如果
此时不把p设置为NULL,会让人误以为p是个合法的指针;
如果程序比较长,有时记不住p所指的内存是否已经被释放,在继续使用p之前,通常
会用语句if(p!=NULL)进行防错处理，很遗憾,此时if语句起不到防错作用,
因为即便p不是NULL指针,它也不会指向合法的内存块;

char *p=(char*)malloc(100);
strcpy(p,"hello");
free(p);//p所指的内存块被释放,但是p所指的地址仍然不变;
...
if(p!=NULL)//没有起到防错作用
{
	strcpy(p."world");//出错
}

3.>指针操作超越了变量的作用范围;这种情况下让人防不胜防;
class A
{
	public:
		  void Func(void)
		  {
			  cout<<" Func of class A"<<endl;
		  }		  
};
void Test(void)
{
	A*p;
	{
		A a;
		p=&a;//注意a的生命期;
	}
	p->Func();//p是"野指针"
}

Dangling pointer(悬垂指针,迷途指针)和Wild pointer(野指针)
1.>迷途指针(悬垂指针)
在计算机编程领域中,迷途指针与野指针指的是不指向任何合法对象的指针;
当所指向的对象被释放或者收回,但是对该指针没有做任何的修改,以至于该指针仍旧指向已经回收
的内存地址,此情况下该指针便称迷途指针(悬垂指针);若操作系统将这部分已经释放的内存重新分配给
另外一个进程,而原来的程序重新引用现在的迷途指针,则将产生无法预料的后果,因为此时迷途指针
所指向的内存现在包含的已经是完全不同的数据;通常来说,若原来的程序继续往迷途指针所指向的内存地址
写入数据,这些和原来程序不相关的数据将被损坏,进而导致不可预料的程序错误;
这种类型的程序错误,不容易找到问题的原因,通常会导致段错误和一般保护错误;
如果操作系统的内存分配器将已经被覆盖的数据区域再分配,就可能会影响系统的稳定性;

二.>迷途指针的成因
在很多编程语言中(C)从内存中删除一个对象或者返回时删除栈帧后,并不会改变相关的指针的值;
该指针仍然指向原来的内存地址,即使引用已经删除,现在也可能被其他进程使用了;


char *cp=NULL;
{
	char c;
	cp=&c;//c falls out of scope
}
上述问题的解决办法是在该部分程序退出之前立即给CP赋0值(NULL),另一个办法是保证CP在没有初始化之前,将不再被使用;

迷途指针经常出现在混杂使用malloc和free()库调用;当指针指向的内存释放了,这时该指针就是迷途的,
和前面的例子一样,一个避免这个错误的方法是在释放它的引用后将该指针的值置为NULL;

{
	char *cp=malloc(A_CONST);
	free(cp);//cp now becomes a dangling pointer
	cp=NULL;
}
有个常见的错误是当返回一个基于栈分配的局部变量的地址时,一旦调用的函数返回,分配给这些变量的空间将
被回收,此时他们拥有的是"垃圾值";
int* func(void)
{
	int num=1234;
	return &num;
}
*/


//更高级的声明方式:
//1.>使用typedef声明函数指针
/*
使用typedef来声明函数,以使代码的可读性更强
*/
//typedef bool(*pCopySDMMC2Mem)(int,unsigned int,unsigned short,unsigned int*,bool);

//pCopySDMMC2Mem pf1,pf2;

//2.>使用define来定义函数指针---制定了指向函数的入口地址(0xD0037F98)
//#define CopySDMMCtoMem(z,a,b,c,e) (((bool(*)(int,unsigned int ,unsigned short,unsigned int*,bool))(*((unsigned int*)0xD0037F98)) )(z,a,b,c,e))
//#define CopySDMMCtoMem(z,a,b,c,e) (((bool(*)(int, unsigned int, unsigned short, unsigned int*, bool))(*((unsigned int *)0xD0037F98)))(z,a,b,c,e))

//2.函数指针的两个典型应用
//1.>将函数作为参数传递给函数
//2.>引用不在代码段的函数
/*
此功能在嵌入式系统中经常使用,用户写的程序在代码段,在嵌入式系统中,一般情况下是存放在flash中;
不在代码段的函数,很多微控制器在出厂前会将一些功能函数(系统函数)固化在rom(类似于PC机中的BIOS),
如flash擦写功能,flash copy功能;我们写的代码是不认识这些函数的,不能直接使用函数名调用,
当我们想在用户程序中调用这些系统函数时,就只能使用函数指针的方式,通过将系统函数逇入口地址
传递给函数指针,来达到调用rom中程序的目的,这些系统函数一般都会在官方手册中给出功能,返回值类型和参数列表;
*/

/*
[root@localhost 0_test]# gdb core core.2859 
GNU gdb (GDB) Fedora (7.2-16.fc14)
Copyright (C) 2010 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "i686-redhat-linux-gnu".
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>...
Reading symbols from /mnt/hgfs/share-2/0_test/core...done.
[New Thread 2859]
Missing separate debuginfo for 
Try: yum --disablerepo='*' --enablerepo='*-debuginfo' install /usr/lib/debug/.build-id/25/7d0d6467b9f4374470e0384a3e602be99b058e
Reading symbols from /lib/libc.so.6...(no debugging symbols found)...done.
Loaded symbols for /lib/libc.so.6
Reading symbols from /lib/ld-linux.so.2...(no debugging symbols found)...done.
Loaded symbols for /lib/ld-linux.so.2
Core was generated by `./core'.
Program terminated with signal 11, Segmentation fault.
#0  0x080483a7 in main () at core.c:5
5		str[1]='H';
Missing separate debuginfos, use: debuginfo-install glibc-2.12.90-17.i686

*/

//测试回调函数,
//测试数组结构中,保存着数组的首地址,然后遍历数组中的数组
/*
函数名就像数组名一样,只不过函数名是代码段的指针,而数组名是数据段的指针;
独有的特点就是:1.>存在于代码段;2.>定值(程序加载进内存后就不能改变了);
相对的,普通的指针是可以移动的(改变它的指向)

---
指针函数的指针包含了函数的地址,可以通过它来调用函数,
类型说明符(*函数名)(参数)
函数名,是指针的变量名,这个特殊的指针指向返回函数值的函数,
指针的声明必须和它指向函数的声明保持一致;

指针名和指针运算符外面的括号改变了默认的运算符优先级;
如果没有圆括号,就变成了一个返回整型指针的函数的圆形声明;
void (*fptr)();
函数的地址赋值给函数指针,采用下面两种形式
fptr=&Function;fptr=function;
去地址运算符&不是必需的,因为单单一个函数标识符就表示了它的地址;
如果函数调用,必须包含一个圆括号括起来的参数表;
可以采用以下两种方式通过指针调用函数
x=(*fptr)();明确指出是通过指针而非函数名来调用函数的
x=fptr();


地址计算公式：
a + num = a的地址 + num*(sizeof(*a))

e.g
a + 1 = a的地址(0076FA80) + 1*(sizeof（*a）)
      = 0076FA80 + sizeof(int)
      = 0076FA80 + 4
      = 0076FA84

&a + 1 = a的地址(0076FA80) + 1*(sizeof（*&a）)
       = 0076FA80 + sizeof(int [10])
       = 0076FA80 + 28
       = 0076FAA8


	   
	   
Table of Contents
Table of Contents
通信方式
信号
互斥锁
条件变量
信号量
信号量与线程锁、条件变量

简单的多线程程序
修改线程的属性
线程的数据处理
互斥锁
信号量



int semt_init(
 semt_t* sem,     //a semaphore pointer
 int     pshared, //0 as a local semaphore of cuurent process, or the semaphore can be shared between mulit processes
 unsigned value   //the init  value of this memaphore
 )


//minus ONE  value of semaphore
int sem_wait(sem_t* sem);

//add ONE value of semaphore
int sem_post(sem_t* sem);


//destroy the semaphore
int sem_destroy(sem_t* sem);

All  the functions above Rerurn ZERO  IF SUCCESS !

*/
/*
C语言函数指针的两种常见用途(回调函数与转移表)
在<<C和指针>>这本书里,C函数指针的常见用法;
1.回调函数
在单链表的查找中,会遇到由于要查找的数据类型不同导致需要编写不同类型的
查找函数,为了方便，运用回调函数法;

1.1查找函数
使用回调函数法,将比较函数作为一个函数指针进行参数传递,这里只用编写一个
查找函数,通过编写不同的比较函数来进行查找的功能;
函数返回指向这个元素节点的指针;

Node* SearchList(LinkList head,const void* value,int(*compare_t)(const void*,const void*))
{
	Node* pnode=head;
	if(IsEmpty(pnode))
	{
		return FLASE;
	}
	pnode=pnode->next;
	while(NULL!=pnode)
	{
		if(compare_t(&pnode->,value)==0)
		{
			break;
		}
		pnode=pnode->next;
	}
	return pnode;
}

1.2比较函数
常见的比较函数如strcmp函数,相同返回0,为了兼容这一点,所以自己编写的函数也采取了
这种模式,不同的是这个比较函数只需要知道是否相同就行,不需要更多的返回值来比较大小;
比较int类型的两个数,相同返回0,否则返回1;


int Compare_ints(const void* a,const void* b)
{
	if(*(int *)a==*(int *)b)
	{
		return 0;
	}
	else
	{
		return 1;
	}

}
2.转移表
这里有一个程序,它的功能是用来实现秀珍计算机,假定ADD是0,SUB是1,MUL是2;

switch(oper)
{
	case ADD:
			result=add(op1,op2);
			break;
	case SUB:
			result=sub(op1,op2);
			break;
	case MUL:
			result=mul(op1,op2);
			break;
	case DIV:
			result=div(op1,op2);
			break;
.......
}

1.声明并初始化一个函数指针数组,注意要确保函数原型出现在数组声明之前
double add(double,double);
double sub(double,double);
double mul(double,double);
double div(double,double);
......
double(*oper_func[])(double,double)=
{
	add,sub,mul,div,......
};
2.用下面的整条语句来代替整条switch语句!
result=oper_func[oper](op1,op2);
oper从数组中选择正确的函数指针,而函数调用操作符将执行这个函数;
*/

/*
函数指针:1.指针变量;2.指针变量指向函数
这正如用指针变量可指向整型变量,字符型,数组一样;
在编译时,每一个函数都有一个入口地址,该入口地址就是函数指针所指向的地址;
可利用该指针变量调用函数,就如同用指针变量可引用其他类型变量一样,在这些概念上
一致的;事实上,每一个函数,即使它不带有返回某种类型的指针,它本身都有一个入口地址，
该地址相当于函数名;
尽管函数不是变量,但它在内存中仍有物理地址,该地址能够赋给指针变量;获取函数方法是:
用不带有括号和参数的函数名得到;
函数名相当于一个指向其函数入口的指针常量;
函数名后面加圆括号,表示函数调用;
若要得到函数的地址,直接用函数名就可以了;
指针/函数和函数指针的区别:
1.指针函数:指带指针的函数,本质上是一个函数;
2.指针函数返回类型是某一类型的指针;

函数指针有两个用途:调用函数和做函数的参数;
函数指针的说明方法为:
数据类型标识符 (指针变量名)(形参列表)
注1:"函数类型"说明函数的返回值,由于"()"的优先级高于"*",所以指针变量名外的括号必不可少,
后面的"形参列表",表示指针变量指向的函数所带的参数列表,
int func(int x);//声明一个函数
int (*f)(int x);//声明一个函数指针
f=func;//将func函数的首地址赋值给指针f;
赋值时函数func不带括号,不带参数,func代表函数的首地址;
注2:函数括号中的形参可有可无,视情况而定;


int max(int x,int y){ return(x>y?x:y); }

void main()
{
	int(*ptr)(int,int);
	int a,b,c;
	ptr=max;
	scanf("%d,%d",&a,&b);
	c=(*ptr)(a,b);
	printf("a=%d,b=%d,max=%d",a,b,c);
}
实际上ptr和max都指向同一个入口地址,不同就是ptr是一个指针变量,不想函数名
那是死的,它可以指向任何函数
注意:指针函数的指针变量没有++和--运算;
*/

char message[]="hello world";
static sem_t re;
	   sem_t g_semt;
int a=0,b=0,number=0;
int ticket=40;
pthread_mutex_t mut;
pthread_mutex_t mutex=PTHREAD_MUTEX_INITIALIZER;//定义初始化锁-互斥锁
typedef struct
{
    char cmd[10];
    //bool is_true;
    unsigned char buf[10];
    int result;
} test_gdb_struct;

struct prodcons
{
	//缓冲区相关数据结构
	int buffer[BUFFER_SIZE];//实际数据存放的数组
	pthread_mutex_t lock;//互斥体lock用于对缓冲区的互斥操作
	int readpos,writepos;//读写指针
	pthread_cond_t notempty;//缓冲区非空的条件变量
	pthread_cond_t notfull;//缓冲区未满的条件变量	
};

struct prodcons buffer;

test_gdb_struct test_gdb_struct_1;

test_gdb_struct data_for_test;
int num_cmd = 1;
void add(test_gdb_struct *data);
void subtraction(test_gdb_struct *data);
void multiplication(test_gdb_struct *data);
void divide(test_gdb_struct *data);

void (*funcp)();
void FileFunc(),EditFunc();
//typedef void (*test_gdb_callback)();
typedef void (*test_gdb_callback)(test_gdb_struct *data);

//初始化缓冲区结构
void init_prodcons(struct prodcons *b)
{
	pthread_mutex_init(&b->lock,NULL);
	pthread_cond_init(&b->notempty,NULL);
	pthread_cond_init(&b->notfull,NULL);
	b->readpos=0;
	b->writepos=0;
}
//生产者将产品放入缓冲区,这里是存入一个整数
void put_prodcons(struct prodcons *b,int data)
{
	pthread_mutex_lock(&b->lock);
	//printf("%s(%d)--put_prodcons--b->writepos=%d,b->readpos=%d\n", __FILE__, __LINE__,b->writepos,b->readpos);
	
	//等待缓冲区未满
	if((b->writepos+1)%BUFFER_SIZE==b->readpos)
	{
		pthread_cond_wait(&b->notfull,&b->lock);
		printf("%s(%d)-----\n", __FILE__, __LINE__);
	}
	
	//写数据,并移动指针
	b->buffer[b->writepos]=data;
	b->writepos++;
	
	if(b->writepos==BUFFER_SIZE)
	{
		b->writepos=0;
	}
	//printf("%s(%d)-----\n", __FILE__, __LINE__);
	//设置缓冲区非空的条件变量
	pthread_cond_signal(&b->notempty);
	pthread_mutex_unlock(&b->lock);
	//printf("%s(%d)-----\n", __FILE__, __LINE__);
}

//从缓冲区取出整数
int get_prodcons(struct prodcons *b)
{
	int data;
	pthread_mutex_lock(&b->lock);
	//等待缓冲区非空
	if(b->writepos==b->readpos)
	{
		pthread_cond_wait(&b->notempty,&b->lock);
		printf("%s(%d)-----\n", __FILE__, __LINE__);
	}
	//读数据,移动读指针
	data=b->buffer[b->readpos];
	b->readpos++;
	if(b->readpos>=BUFFER_SIZE)
	{
		b->readpos=0;
	}
	//设置缓冲区未满的条件变量
	pthread_cond_signal(&b->notfull);
	pthread_mutex_unlock(&b->lock);
	return data;
}


void* producer_prodcons(void *data)
{
	int n;
	for(n=0;n<40;n++)
	{
		printf("%d--->\n",n);
		put_prodcons(&buffer,n);
	}
	put_prodcons(&buffer,OVER);
	return NULL;
}
void* consumer_prodcons(void *data)
{
	int d;
	while(1)
	{
		d=get_prodcons(&buffer);
		if(d==OVER)
		{
			break;
		}
		printf("--->%d\n",d);
	}
	return NULL;
}

//------------------------------------------
void FileFunc()
{
	printf("%s(%d)--FileFunc--\n", __FILE__, __LINE__);
}
void EditFunc()
{
	printf("%s(%d)--EditFunc--\n", __FILE__, __LINE__);
}
void add_1()
{
	printf("%s(%d)--add_1\n", __FILE__, __LINE__);
}
//-------------------------
//两个线程同时调用一个线程函数会怎么样,MultiThread
void add_test_address_for_pthread()
{
	sleep(1);
	printf("%s(%d)--add_test_address_for_pthread--%x\n", __FILE__, __LINE__,pthread_self());
}

void *thread_function(void* arg)
{
	printf("%s(%d)--%lu-thread_function is running;Argument was %s\n",__FILE__,__LINE__,pthread_self(),(char*)arg);
	sleep(3);
	stpcpy(message,"Bye!");
	pthread_exit("Thank you for the CPU time\n");
}

void *thread_start(void* arg)
{
	while(1)
	{
		pthread_mutex_lock(&mutex);
		if(ticket>0)
		{
			usleep(1000*10*1);
			printf("%s(%d)yellow bull:%d---get ticket:%d\n",__FILE__,__LINE__,(int)arg,ticket);
			ticket--;
		}
		else
		{
			pthread_mutex_unlock(&mutex);
			pthread_exit(NULL);
		}
		pthread_mutex_unlock(&mutex);
	}
	return NULL;
}

void *thread_1()
{
	int i=0;
	printf("%s(%d)--thread_1 is running....\n",__FILE__,__LINE__);
	for(i=0;i<10;i++)
	{
		printf("%s(%d)--thread_1:number=%d\n",__FILE__,__LINE__,number);
		pthread_mutex_lock(&mut);
		number++;
		pthread_mutex_unlock(&mut);
		sleep(2);
	}
	printf("%s(%d)--thread_1:main thread is still waiting for thread_1\n",__FILE__,__LINE__);
	pthread_exit(NULL);
}

void *thread_2()
{
	int i=0;
	printf("%s(%d)--thread_2 is running....\n",__FILE__,__LINE__);
	for(i=0;i<10;i++)
	{
		printf("%s(%d)--thread_2:number=%d\n",__FILE__,__LINE__,number);
		pthread_mutex_lock(&mut);
		number++;
		pthread_mutex_unlock(&mut);
		sleep(3);
	}
	printf("%s(%d)--thread_2:main thread is still waiting for thread_2\n",__FILE__,__LINE__);
	pthread_exit(NULL);
}

void thread_test()
{
	int i=0;
	for(i=0;i<3;i++)
	{
		printf("this is a child pthread\n");
	}
	return ;
}


void *add_test_address()
{
	int i=0;
	while(1)
	{
		sleep(1);
		for(i=0;i<10;i++)
		{
			printf("%s(%d)--add_test_address-%d-%lu\n", __FILE__, __LINE__,i,pthread_self());
		}	
		if(i ==10)
		{
			break;
		}	
	}
	
}
void *sub_test_address()
{
	sleep(1);
	printf("%s(%d)--sub_test_address--%lu\n", __FILE__, __LINE__,pthread_self());
}
void *multi_test_address()
{
	sleep(1);
	printf("%s(%d)--multi_test_address-%lu-\n", __FILE__, __LINE__,pthread_self());
}
void *divide_test_address()
{
	sleep(1);
	printf("%s(%d)--divide_test_address-%lu-\n", __FILE__, __LINE__,pthread_self());
}
void *power_test_address()
{
	sleep(1);
	printf("%s(%d)--power_test_address-%lu-\n", __FILE__, __LINE__,pthread_self());
}

void* work_thread()
{
	pthread_t t_id=pthread_self();
	printf("--%lu--is waiting for a semaphore--\n",t_id);
	sem_wait(&g_semt);
	printf("--%lu--got a semaphore,is running--\n",t_id);
	usleep(1000*1000*2);
	
	sem_post(&g_semt);
	static char* pRet="thread finished!\n";
	return pRet;
}

//-------------------------

int max_int(int a,int b)
{
	return (a>b)?a:b;
}

void PrintNum(int n)
{
   printf("Test1 is called,the number is %d\n",n);
} 

void ShowNum(int n,void (* ptr)())
{
   (* ptr)(n);
} 
void PrintMessage1()
{
   printf("This is the message 1!\n");
} 
void PrintMessage2()
{
   printf("This is the message 2!\n");
} 
void PrintMessage3()
{
   printf("This is the message 3!\n");
} 
void ShowMessage(void (* ptr)())
{
    (* ptr)();
}


//-----------
void add(test_gdb_struct *data)
{    
    //printf("%s(%d)--add--%d\n", __FILE__, __LINE__, num_cmd);
	printf("%s(%d)--add\n", __FILE__, __LINE__);
}
//minus 减号.subtraction 减法
void sub(test_gdb_struct *data)
{
    //printf("%s(%d)--sub--%d\n", __FILE__, __LINE__, num_cmd);
	printf("%s(%d)--sub\n", __FILE__, __LINE__);
}
void multi(test_gdb_struct *data)
{
    //printf("%s(%d)--multi--%d\n", __FILE__, __LINE__, num_cmd);
	printf("%s(%d)--multi\n", __FILE__, __LINE__);
}
void divide(test_gdb_struct *data)
{
    //printf("%s(%d)--divide--%d\n", __FILE__, __LINE__, num_cmd);
	printf("%s(%d)--divide\n", __FILE__, __LINE__);
}

void *get_fm( )
{
	b=2;
	//sleep(1);
	sem_post(&re);
	printf("%s(%d)--b=%d--re=%lu\n",__FILE__,__LINE__,b,re);
}

void *get_fz( )
{
	a=20;
	//sleep(2);
	sem_post(&re);
	printf("%s(%d)--a=%d--re=%lu\n",__FILE__,__LINE__,a,re);
}

void *get_re( )
{
	//sleep(3);	
	sem_wait(&re);
	printf("%s(%d)--a=%d--b=%d--re=%lu\n",__FILE__,__LINE__,a,b,re);
	sem_wait(&re);
	printf("%s(%d)--a=%d--b=%d--(a/b)=%d--re=%lu\n",__FILE__,__LINE__,a,b,(a/b),re);
	
}

test_gdb_callback * assemble[]=
{
	add,sub,multi,divide
};
test_gdb_callback assemble_2[]=
{
	add_test_address,sub_test_address,multi_test_address,divide_test_address,power_test_address
};

/*
收到命令以后,根据命令调用函数,然后
判断命令是否满足执行条件，然后决定执行与否
执行函数,然后修改数据结构中的数据;

typedef struct
{
    char *cmd_1;
    //bool is_true;
    test_gdb_callback handler;
    //test_gdb_struct *data_1;
} test_matrix;

static test_matrix_v_1 status_array[] =
{
    status_1, status_2, status_3, status_4
};

*/


typedef struct
{
    int num;
    test_gdb_callback handler;
} test_matrix_v_1;

static test_matrix_v_1 status_1[] =
{
    {2, add},
    {3, sub}
};
static test_matrix_v_1 status_2[] =
{
    {3, sub},
     {4, multi}
};
static test_matrix_v_1 status_3 =
{
    4, multi
};
static test_matrix_v_1 status_4 =
{
    5, divide
};


/*
test_callback.c:102:5: 错误：初始值设定元素不是常量
test_callback.c:102:5: 错误：(在‘status_array[2]’的初始化附近)
*/
static test_matrix_v_1 *status_array[] =
{
    status_1, status_2
};

/*
test_callback.c(91)--add
test_callback.c(97)--sub
test_callback.c(102)--multi
test_callback.c(107)--divide
*/
void test_fun_pointer()
{		
	((void(*)())assemble[0])(&test_gdb_struct_1);
	((void(*)())assemble[1])(&test_gdb_struct_1);
	((void(*)())assemble[2])(&test_gdb_struct_1);
	((void(*)())assemble[3])(&test_gdb_struct_1);
	
	(void(*)())(*add_test_address)();
	
	((void(*)())(assemble_2[0]))();
	((void(*)())(assemble_2[1]))();
}

void test_callback()
{
		(*(status_4.handler))(&test_gdb_struct_1);
		(*(status_1[1].handler))(&test_gdb_struct_1);
		(*(status_1[0].handler))(&test_gdb_struct_1);
		printf("%s(%d)---(*(status_1[0].handler))=%x\n",__FILE__,__LINE__,(*(status_1[0].handler)));
		ShowNum(11111,PrintNum);
		ShowNum(22222,PrintNum);
		ShowMessage(PrintMessage1);
		ShowMessage(PrintMessage2);
		ShowMessage(PrintMessage3);
        /* status_4.handler(&test_gdb_struct_1);
        status_1.handler(&test_gdb_struct_1);
        status_2.handler(&test_gdb_struct_1);
        status_3.handler(&test_gdb_struct_1); */

       /* if (status_4.num== 5)
        {
           status_4.handler(&test_gdb_struct_1);
        }
       if (status_1.num== 2)
        {
           status_1.handler(&test_gdb_struct_1);
        }
       if (status_2.num== 3)
        {
           status_2.handler(&test_gdb_struct_1);
        }
       if (status_3.num== 4)
        {
           status_3.handler(&test_gdb_struct_1);
        } */	
}


void test_callback_0()
{
	
}
void print_info()
{
	/* test_callback.c: 在函数‘print_info’中:
	test_callback.c:191:38: 警告：从不兼容的指针类型初始化 */	
	//test_matrix_v_1 *status_table_tmp = &(status_array[0]);
	

    
    printf("%s(%d)----&status_1[0]=%x--&status_1[1]=%x\n", __FILE__, __LINE__, &(status_1[0]),&(status_1[1]));	
	printf("%s(%d)---status_1[0]=%x--status_1[1]=%x\n",__FILE__,__LINE__,status_1[0],status_1[1]);	
	//printf("%s(%d)---add=%x\n"__FILE__,__LINE__,*add);
	printf("\n");
	
	//!!!!!!!!!!!!!!!
	//printf("%p\n");
    printf("%s(%d)----status_2[0]=%x--status_2[1]=%x\n", __FILE__, __LINE__, status_2[0],status_2[1]);
    printf("%s(%d)----status_array=%x--status_3=%x\n", __FILE__, __LINE__, status_array,status_3);
    printf("%s(%d)----status_array=%x--status_4=%x\n", __FILE__, __LINE__, status_array,status_4);

    printf("\n");
    printf("%s(%d)--%d\n", __FILE__, __LINE__,sizeof(test_matrix_v_1));
    printf("%s(%d)----sizeof(status_1)=%d--sizeof(status_2)=%d\n", __FILE__, __LINE__, sizeof(status_1),sizeof(status_2));
    printf("%s(%d)----sizeof(status_array)=%d--sizeof(status_3)=%d\n", __FILE__, __LINE__, sizeof(status_array),sizeof(status_3));
    printf("%s(%d)----sizeof(status_array)=%d--sizeof(status_4)=%d\n", __FILE__, __LINE__, sizeof(status_array),sizeof(status_4));	
}

void test_fptr()
{
	int address=0;
	funcp=FileFunc;
	(*funcp)();
	funcp=EditFunc;
	(*funcp)();
	address=(int)add_1;//用整数保存函数地址
	((void(*)())address)();//通过地址调用add_1	
	printf("%s(%d)---test_fptr--\n", __FILE__, __LINE__);
	printf("%s(%d)---address=%x\n",__FILE__,__LINE__,address);
	printf("\n");
	address=(int)add;
	printf("address=(int)(status_1[0].handler)\n");
	printf("%s(%d)---address=%x\n",__FILE__,__LINE__,address);	
	address=(int)(status_1[0].handler);
	printf("%s(%d)---address_p=%p\n",__FILE__,__LINE__,(status_1[0].handler));
	printf("%s(%d)---(*(status_1[0].handler))=%x\n",__FILE__,__LINE__,(*(status_1[0].handler)));
	printf("%s(%d)---address=%x\n",__FILE__,__LINE__,address);
	printf("\n");
	address=(int)(*add_test_address);
	printf("address=(int)(*add_test_address)\n");
	printf("%s(%d)---address=0x%x\n",__FILE__,__LINE__,address);	
	printf("%s(%d)---address_p----=%p\n",__FILE__,__LINE__,(*add_test_address));
	printf("%s(%d)---assemble_2[0]=0x%x\n",__FILE__,__LINE__,assemble_2[0]);
	printf("%s(%d)---address_p----=%p\n",__FILE__,__LINE__,(*sub_test_address));	
	printf("%s(%d)---assemble_2[1]=0x%x\n",__FILE__,__LINE__,assemble_2[1]);
	printf("\n");
	printf("address_callback_(int)add\n");
	((void(*)())address)(&test_gdb_struct_1);
	//(*(address))(&test_gdb_struct_1);
	(*(status_1[0].handler))(&test_gdb_struct_1);
	//printf("%s(%d)---add_test_address=%x,&add_test_address=%x\n"__FILE__,__LINE__,add_test_address,&add_test_address);	
}

void test_array()
{
	int test_array_1[10];
	int test_array_a[10];
	int test_array_2[10];
	int ii=0;
	int address_array=0;
	for(ii=0;ii<10;ii++)
	{
		test_array_1[ii]=ii+10;
		test_array_2[ii]=ii+20;
		test_array_a[ii]=ii+30;
		//printf("%s(%d)---a+1    =%p\n", __FILE__, __LINE__,a+ii);
		
	}
	//printf("%s(%d)---test_fptr--\n", __FILE__, __LINE__);
	//整型数据指针的数组
	int* array[3]={
		test_array_1,
		test_array_a,
		test_array_2
	};
	//printf("%s(%d)---test_fptr--\n", __FILE__, __LINE__);
	printf("%s(%d)-----&test_array_1[0]=%p\n", __FILE__, __LINE__,&test_array_1[0]);
	printf("%s(%d)-----&test_array_a[0]=%p\n", __FILE__, __LINE__,&test_array_a[0]);
	printf("%s(%d)-----&test_array_2[0]=%p\n", __FILE__, __LINE__,&test_array_2[0]);
	printf("%s(%d)-----array[0]--------=0x%x\n", __FILE__, __LINE__,array[0]);
	printf("%s(%d)-----array[1]--------=0x%x\n", __FILE__, __LINE__,array[1]);
	printf("%s(%d)-----array[2]--------=0x%x\n", __FILE__, __LINE__,array[2]);
	//printf("%s(%d)-----test_array_a    =%p\n", __FILE__, __LINE__,test_array_a);
	//printf("%s(%d)-----&test_array_a   =%p\n", __FILE__, __LINE__,&test_array_a);	
	printf("\n");
	//printf("%s(%d)---&test_array_a[0]+1=%p\n", __FILE__, __LINE__,&test_array_a[0]+1);
	//printf("%s(%d)---test_array_a+1    =%p\n", __FILE__, __LINE__,test_array_a+1);
	//printf("%s(%d)---&test_array_a+1   =%p\n", __FILE__, __LINE__,&test_array_a+1);	
	
	//printf("%s(%d)-----&test_array_a[0]=%p\n", __FILE__, __LINE__,&test_array_a[9]);
	//printf("%s(%d)-----test_array_a    =%p\n", __FILE__, __LINE__,test_array_a+9);
	printf("%s(%d)-----*test_array_1   =%d\n", __FILE__, __LINE__,*test_array_1);
	printf("%s(%d)-----*test_array_a   =%d\n", __FILE__, __LINE__,*test_array_a);
	printf("%s(%d)-----*test_array_2   =%d\n", __FILE__, __LINE__,*test_array_2);
	printf("%s(%d)-----*(array[0])-----=%d\n", __FILE__, __LINE__,*(array[0]));
	printf("%s(%d)-----*(array[1])-----=%d\n", __FILE__, __LINE__,*(array[1]));
	printf("%s(%d)-----*(array[2])-----=%d\n", __FILE__, __LINE__,*(array[2]));
	
	printf("%s(%d)-----*(array[0])+1---=%d\n", __FILE__, __LINE__,*(array[0])+1);
	printf("%s(%d)-----*(array[1])+1---=%d\n", __FILE__, __LINE__,*(array[1])+1);
	printf("%s(%d)-----*(array[2])+1---=%d\n", __FILE__, __LINE__,*(array[2])+1);
	
	printf("%s(%d)---sizeof(test_array_2)=%d\n", __FILE__, __LINE__,(sizeof(test_array_2))/(sizeof(int)));
	//printf("%s(%d)---strlen(test_array_2)=%d\n", __FILE__, __LINE__,strlen(test_array_2));
	printf("\n");
	
	//printf("%s(%d)---test_fptr--%d\n", __FILE__, __LINE__,ii);
	for(ii=0;ii<10;ii++)
	{
		printf("ii=%d-%d-%d-%d\n",ii,(*(array[0])+ii),(*(array[1])+ii),(*(array[2])+ii));
	}
	
	printf("%s(%d)-----*test_array_1+1 =%d\n", __FILE__, __LINE__,*test_array_1+1);
	printf("%s(%d)-----*test_array_a+1 =%d\n", __FILE__, __LINE__,*test_array_a+1);
	printf("%s(%d)-----*test_array_2+1 =%d\n", __FILE__, __LINE__,*test_array_2+1);
	
	//下面有问题---待续...
	//address_array=(int)test_array_1;
	//printf("%s(%d)---test_array_1=%p\n"__FILE__,__LINE__,test_array_1);
	//address_array=(int)test_array_2;
	//printf("%s(%d)---test_array_2=%p\n"__FILE__,__LINE__,test_array_2);
	
}

void test_pthread_0()
{
	pthread_t tid;
	int i,ret;
	ret=pthread_create(&tid,NULL,(void*)thread_test,NULL);
	if(ret!=0)
	{
		printf("pthread_create error\n");
		exit(1);
	}
	//usleep(1);
	for(i=0;i<3;i++)
	{
		printf("this is main thread\n");
	}
	pthread_join(tid,NULL);
	printf("pthread_join\n");
	return ;
}

void test_pthread_1()
{
	int ret=0;
	pthread_t pid;
	pthread_t pid_0;
	pthread_t pid_1;
	ret=pthread_create(&pid,NULL,(assemble_2[0]),NULL);
	if(ret!=0)
	{
		printf("%s(%d)--%d\n",__FILE__,__LINE__,ret);
	}
	else
	{
		printf("%s(%d)--%d\n",__FILE__,__LINE__,ret);
	}
	ret=pthread_create(&pid,NULL,add_test_address,NULL);
	if(ret!=0)
	{
		printf("%s(%d)--%d\n",__FILE__,__LINE__,ret);
	}
	else
	{
		printf("%s(%d)--%d\n",__FILE__,__LINE__,ret);
	}
	ret=pthread_create(&pid_0,NULL,(void*)add_test_address_for_pthread,NULL);
	if(ret!=0)
	{
		printf("%s(%d)--%d\n",__FILE__,__LINE__,ret);
	}
	else
	{
		printf("%s(%d)--%d\n",__FILE__,__LINE__,ret);
	}
	
	//while(1);
	pthread_exit(NULL);//等待各个线程退出后,进程才结束,否则进程强制结束,线程处于未终止的状态
	return ;
}

void test_join()
{
	pthread_t thread[2];
	int ret=-1;
	printf("%d\n",sizeof(thread));
	//用默认属性初始化互斥锁
	pthread_mutex_init(&mut,NULL);
	
	printf("%s(%d)--test_join is creating threads....\n",__FILE__,__LINE__);
	ret=pthread_create(&thread[0],NULL,thread_1,NULL);
	if(ret!=0)
	{
		printf("thread_1 pthread_create failed\n");
	}
	ret=pthread_create(&thread[1],NULL,thread_2,NULL);
	if(ret!=0)
	{
		printf("thread_2 pthread_create failed\n");
	}
	printf("%s(%d)--test_join pthread_create finished ....\n",__FILE__,__LINE__);
	
	printf("%s(%d)--test_join thread_wait....\n",__FILE__,__LINE__);
	//等待线程
	if(thread[0]!=0)
	{
		pthread_join(thread[0],NULL);
		printf("%s(%d)--thread_1 end....\n",__FILE__,__LINE__);
	}
	if(thread[1]!=0)
	{
		pthread_join(thread[1],NULL);
		printf("%s(%d)--thread_2 end....\n",__FILE__,__LINE__);
	}
	
	return ;
}
void test_pthread_array()
{
	int ret=0;
	int i=0;
	pthread_t pid[NUM_THREADS];
	for(i=0;i<NUM_THREADS;i++)
	{
		ret=pthread_create(&pid,NULL,(assemble_2[i]),NULL);
		if(ret!=0)
		{
			printf("%s(%d)-%d-%d--pthread_create  failed\n",__FILE__,__LINE__,i,ret);
		}
		else
		{
			printf("%s(%d)-%d-%d---pthread_create success\n",__FILE__,__LINE__,i,ret);
		}
	}
	//pthread_exit(NULL);//等待各个线程退出后,进程才结束,否则进程强制结束,线程处于未终止的状态
	return ;
}

void test_pthread_with_arg()
{
	int ret=-1;	
	pthread_t pid;
	void *thread_result;
	ret=pthread_create(&pid,NULL,thread_function,(void*)message);
	if(ret!=0)
	{
		printf("%s(%d)--%d--%lu\n",__FILE__,__LINE__,ret,pid);
		perror("pthread_create failed\n");
	}
	else
	{
		printf("%s(%d)--%d--%lu\n",__FILE__,__LINE__,ret,pid);
	}
	printf("%s(%d)waiting for pthread_create to finish...\n",__FILE__,__LINE__);	
	//阻塞执行的线程知道某线程结束
	ret=pthread_join(pid,&thread_result);
	if(ret!=0)
	{
		perror("pthread_join failed\n");
	}
	printf("%s(%d)thread_join,it returned %s\n",__FILE__,__LINE__,(char*)thread_result);
	printf("%s(%d) Message is now %s\n",__FILE__,__LINE__,message);
	exit(EXIT_SUCCESS);
}
//线程间通信
//信号量
void test_pthread_sem()
{
	pthread_t pthread_fz;
	pthread_t pthread_fm;
	pthread_t pthread_re;
	//初始化信号量
	sem_init(&re,0,0);
	pthread_create(&pthread_fm,NULL,get_fm,NULL);
	pthread_create(&pthread_fz,NULL,get_fz,NULL);	
	pthread_create(&pthread_re,NULL,get_re,NULL);
	//线程添加到主线程的控制下
	pthread_join(pthread_fm,NULL);
	pthread_join(pthread_fz,NULL);	
	pthread_join(pthread_re,NULL);
	//销毁信号量
	sem_destroy(&re);
}

void test_pthread_sem_0()
{
	const int nThreadCount=5;// amount of thread array 
	const unsigned int nSemaphoreCount=2;//initial value of semaphore
	int nRet=-1;
	int nRet_1=-1;
	int i=0;
	void *pRet=NULL;
	pthread_t threadIDs[5]={0};
	nRet=sem_init(&g_semt,0,2);
	//nRet=sem_init(&g_semt,0,nSemaphoreCount);
	if(0!=nRet)
	{
		return -1;
	}
	for(i=0;i<5;i++)
	{
		nRet=pthread_create(&threadIDs[i],NULL,work_thread,NULL);
		if(0!=nRet)
		{
			continue;
		}
		else
		{
			printf("thread:%lu pthread_create \n",threadIDs[i]);
		}
	}
	for(i=0;i<5;i++)
	{
		nRet_1=pthread_join(threadIDs[i],&pRet);
		printf("thread:%lu return value is %s\n",threadIDs[i],pRet);
	}
	//printf("\n");
	
	sem_destroy(&g_semt);
		
}

void test_pthread_mutex()
{
	//模拟黄牛抢票,100张票,四个黄牛在抢票
	pthread_t tid[4];
	int i=0,ret=0;
	pthread_mutex_init(&mutex,NULL);
	for(;i<4;i++)
	{
		ret=pthread_create(&tid[i],NULL,thread_start,(void*)i);
		if(0!=ret)
		{
			printf("%s(%d)yellow bull no exit!");
			return -1;
		}
	}
	for(i=0;i<4;i++)
	{
		pthread_join(tid[i],NULL);
	}
	pthread_mutex_destroy(&mutex);
	return ;	
}

void test_consumer_producer_cond_mutex()
{
	pthread_t th_a,th_b;
	void *retval;
	init_prodcons(&buffer);
	//创建生产者和消费者线程
	pthread_create(&th_a,NULL,producer_prodcons,0);
	pthread_create(&th_b,NULL,consumer_prodcons,0);
	//等待两个线程结束
	pthread_join(th_a,&retval);
	pthread_join(th_b,&retval);
	return ;
}


void test_gdb_1()
{
	char *str="hello world";
	str[1]='H';
	return 0;
}

void test_gdb_2()
{
	char *pStr="hello world";
	free(pStr);
}
int main()
{
    int ii = 0;
    int process_id = getpid();
    char cmd[128]={0};
    //test_matrix_v_1 *status_table_tmp = NULL;
    //test_fptr();
    //test_callback();
	//test_array();
	//test_fun_pointer();
	//test_pthread_with_arg();
	//test_pthread_1();
	test_pthread_array();
	//test_pthread_sem();
	//test_pthread_sem_0();
	//test_pthread_mutex();
	//test_join();
	//test_gdb_1();
	//test_gdb_2();
	//test_pthread_0();
	//printf("%s(%d)-----\n", __FILE__, __LINE__);
	//test_consumer_producer_cond_mutex();
	snprintf(cmd, sizeof(cmd), "pstack %d", process_id);
	//printf("%s\n",cmd);
	printf("%s(%d)----%s\n", __FILE__, __LINE__,cmd);
	printf("%s(%d)--process_id--%d\n", __FILE__, __LINE__, process_id);
    while (ii <= 7)
    {
        
//        if(i==((*status_table_tmp).num))
//            {
//                printf("%s(%d)--if--%d\n", __FILE__, __LINE__, i);
//                (*status_table_tmp).handler(&test_gdb_struct_1);
//        }       
        //ii++;
	//printf("%s(%d)--if--%d\n", __FILE__, __LINE__, ii);
	
	system(cmd);
	//printf("%s(%d)---ii=%d--sss--\n", __FILE__, __LINE__,rand()%7);
        //printf("%s(%d)--%d--%d--%d--%d--%d\n", __FILE__, __LINE__,i,status_4.num,status_3.num,status_2.num,status_1.num);
        //num_cmd++;
    }
    //while(1);
    //system("pause");
    return 0;
}
