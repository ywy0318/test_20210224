#define _CRT_SECURE_NO_WARNINGS
#include<dos.h>
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#include<math.h>
#include<time.h>
#include<windows.h>
#include<conio.h>


/*
你肯定没搞过单片机，在单片机上我恨不得用汇编……（特别是在逻辑不复杂的情况下）
C的指针是对“底层可操作性”的一种妥协，至于其他童鞋说的 ‘将“地址”变量化的能力’ 那个就不是C中狭义的“指针”了，
毕竟引用是不能随便在内存地址空间上随便移动了
（对于单片机这样和硬件打交道比较多的平台，这是好事，
但是如果专注于较高层次的逻辑的话，这是坏事，因为你的注意力经常要被野指针、内存泄漏等等坑爹的事情给吸引过去）
所以，在拥有合适工具（比如Java的引用+GC，C++11的智能指针）并且不需要直接和硬件打交道的场景下，还是尽量不要用指针比较好
*/


/*
指针的本意是：在一个变量中保存另一个变量的地址，以提供将“地址”变量化的能力。如果没有指针，将无法用一个变量引用另一个变量（只能把变量的值拷贝一份赋给另一个变量）。

C语言中提供了完善的指针操作，包括为指针赋值、内存分配（malloc）、取变量地址、让指针可以参与运算等，这使得C程序员能够任意操作可用内存。

Java（Javascript）中也有指针，只不过与C相比，Java对程序员使用指针有着严格的限制，仅允许赋值操作，而且不是任意值，只能是通过new创建的对象引用或其他引用变量的值。不过Java一般不说指针，而是用引用（reference）来称呼指向对象的指针，不过，Java中仍然可以找到一些指针存在的影子，例如，当一个对象为null时调用方法会导致null pointer异常，即所谓的空指针错误，可见Java内部使用的确实是指针。

很多基本的数据结构，例如链表、树、图等，都必须用指针来保存前驱或后继节点的地址，否则这些数据结构无法实现。

如果一个语言不提供指针，虽然在理论上它也具备完整的计算能力，但很多在其他语言中非常简单的问题都将变得极其复杂（本来想举个例子的，但一时想不起了，不过这个结论肯定是正确的）。

所以这个作者说的是对的，只是你需要理解指针的本质，不要错误地认为只有像C语言那样的指针才叫指针，真正的指针的概念请看我开头的那句。


*/

/*
相当于动态链表,静态链表消耗空间要少一点
不少吧？一个指针和一个int的索引在x86下占用的空间是一样的。
区别1 在于存储分配，数组只要分配一次，剩下的就是迭加索引，而node＋指针 ，则要一个node分配一次。当然采用内存池或者GC就另当别论了。
区别2 在于该死的大量的指针是难于分析的，从而造成优化的困难。


*/
//FAT文件系统就静态链表实现，针对没有指针的语言
//融合顺序表和链表各自的优点,从而既能快速访问元素,又能快速增加或删除数据元素;
//静态链表,也是线性存储结构的一种，兼顾了顺序表和链表的优点，可以看做是顺序表和链表的升级版
//使用静态链表的存储数据，数据全部存储在数组中(和顺序表一样)，但存储位置是随机的，
//数据之间“一对一”的逻辑关系通过一个整型变量(称为“游标”，和指针功能类似)维持（和链表相似）
//静态链表中的节点
/*
通过上面的学习我们知道，静态链表存储数据元素也需要自定义数据类型,至少需要包含以下两部分信息:
数据域：用于存储数据元素的值
游标：其实就是数组下标，表示直接后继元素所在数组中的位置；

图2显示的静态链表还不够完整，静态链表中，除了数据本身通过游标组成的链表外，还需要有
一条连接各个空闲位置的链表，成为备用链表
备用链表的作用是回收数组中未使用或者之前使用过(目前未使用的)的存储空间，留待后期使用
也就是说，静态链表使用数组申请的物理空间中，存有两个链表，一条连接数据，另外一条连接
数组中未使用的空间；
通常，备用链表的表头位域数组下标为0(a[0])的位置，而数据链表的表头位于数组下标为1(a[1])的位置
静态链表中设置备用链表的好处是,可以清楚地知道数组中是否有空闲位置，以便数据链表添加新数据时使用，
比如，若静态链表中数组下标为0的位置上有数据,则证明数组已满；
例如，使用静态链表存储{1，2，3}，假设使用长度为6的数组a,则存储状态可能存储为如下
备用链表上连接的依次是a[0],a[2],a[4],而数据链表上连接的依次是a[1],a[3],a[5]

静态链表的实现
假设使用静态链表(数组长度为6)存储{1，2，3}，需要经历以下几个阶段;
在数据链表未初始化之前，数组中所有位置都处于空闲状态,因此都应被连接在备用链表上，
当想静态链表中添加数据时,需提前从备用链表中摘除节点，以供新数据使用;
备用链表摘除节点最简单的方法是a[0]的直接后继节点;同样，向备用链表中添加空闲节点也是作为a[0]新的直接后继节点，
因为a[0]是备用链表的第一个节点，我们知道它的位置，操作它的直接后继节点相对容易，无需遍历备用链表，
时间复杂度为O(1);

*/
//因此,静态链表中节点的构成用C语言实现:
#define maxSize 24
typedef struct{
	int data;//数据域
	int cur;//游标
}component;

//从备用链表上摘下空闲节点的函数
//提取分配空间
//找到下一个空闲的节点，就是还未使用的节点,然后把空闲节点的索引后移
int malloc_arr(component *array_3)
{
	//若备用链表非空，则返回分配的节点下标，否则返回为0
	//当分配最后一个节点时，该节点的游标值为0
	//检查找到备用链表的下一个还未使用的索引值，
	//如果下一个备用链表的未使用的索引值不是0的话，那么说明还有
	//未使用的,那么就把0指向下一个未使用的，然后返回分配的
	//链表的索引下标
	int i=array_3[0].cur;
	if(array_3[0].cur)
	{
		array_3[0].cur=array_3[i].cur;
	}
	return i;
}

//将结构体数组中所有分量链接到备用链表上
//创建备用链表
void reserveArr(component *array_0)
{
	int i=0;
	for(i=0;i<maxSize;i++)
	{
		//将每个数组分量链接到一起
		array_0[i].cur=i+1;
		printf("%d,%d\n",i,array_0[i].cur);
	}
	printf("---\n");
	//链表最后一个节点的游标值标记为0
	array_0[maxSize-1].cur=0;
	printf("%d,%d\n",(maxSize-1),array_0[maxSize-1].cur);
	
}
//初始化静态链表
int init_arr(component *array_1)
{
	int i=0;
	int j=0;
	int body=0;
	int tempbody=0;
	reserveArr(array_1);
	body=malloc_arr(array_1);
	//声明一个变量，把它当指针使，指向链表的最后一个节点，因为链表为空，
	//所以和头节点重合
	tempbody=body;
	printf("before for:%d\n",tempbody);
	for(i=1;i<4;i++)
	{
		j=malloc_arr(array_1);//从备用链表中拿出空闲的分量
		//printf("in for:%d\n",j);
		array_1[tempbody].cur=j;//将申请的空闲分量链接在链表的最后一个节点后面
		array_1[j].data=i;//给新申请的分量的数据域初始化
		tempbody=j;//将指向链表的最后一个节点的指针后移;
		printf("value:%d,%d,%d\n",i,array_1[i].data,array_1[i].cur);
	}
	array_1[tempbody].cur=0;//新的链表最后一个节点的指针设置为0；
	return body;

}
//输出函数
void display_arr(component *array_2,int body){
	int tempbody=body;//tempbody准备做遍历使用
	while(array_2[tempbody].cur){
		printf("data:cur:%d,%d\n",array_2[tempbody].data,array_2[tempbody].cur);
		tempbody=array_2[tempbody].cur;
	}
	printf("data:cur:%d,%d\n",array_2[tempbody].data,array_2[tempbody].cur);
	//return ;
}
void display_all(component *array_5)
{
	int i=0;
	for(i=0;i<maxSize;i++)
	{
		printf("%d,%d,%d\n",i,array_5[i].data,array_5[i].cur);
	}
}


int main()
{	
	static component array_4[maxSize];
	int bd=init_arr(array_4);
	printf("静态链表 %d:\n",bd);
	display_arr(array_4,bd);
	//display_all(array_4);
	system("pause");
	return 0;
}